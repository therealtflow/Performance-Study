{\rtf1\ansi\ansicpg1252\cocoartf2709
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fswiss\fcharset0 Helvetica-Bold;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 \

\f1\b 1. What speedup does Amdhal\'92s law project for 4 threads? Use the sequential execution time as the baseline.
\f0\b0 \
	  - It projects a 3.149x speedup\
\
	
\f1\b What speedup was actually observed? Why or why not?\
		 - 
\f0\b0 The speedup observed was 2.886x, I assume this is because I only used two decimal points as well as because Amdahl\'92s law predicting slightly higher speedup times than what is realistic\
\
\

\f1\b 2. What speedup does Amdhal\'92s law project for 16 threads? Use the sequential execution time as the baseline. \
	 - 
\f0\b0 Amdahl\'92s law predicted a 6.80x speedup\
	
\f1\b What speedup was actually observed? Why or why not? \
		 - 
\f0\b0 A 5.265x speedup, this could be because the numbers I used were not 100% accurate as well as the fact that Amdhal\'92s law tends to predict slightly higher speedup than what is realistic. \
\
\
\pard\pardeftab720\partightenfactor0

\f1\b \cf0 FILE CONTENTS
\f0\b0 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 The Chart Graphs are in the file 
\f1\b Charts.pdf
\f0\b0 \
C file is 
\f1\b matrix_multiplication.c
\f0\b0 \
Makefile is 
\f1\b Makefile
\f0\b0 \

\f1\b Slurm-208244.out
\f0\b0  is the output from Centaurus after running the program\

\f1\b gemm_benchmark.sh
\f0\b0  is the script used to run the C file in Centaurus \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 \
\
README:::::\
//concise overview of methodology and findings\
\
I was provided a c program and makefile to correctly compile the program, from there I wrote a script that allowed the program to be computed within Centaurus.\
\
Within the script I included all of the information needed to process the job in Centaurus as well as the different thread counts and problem sizes for the program I used a combination of 5 different thread counts and 8 different problem sizes to run the program 40 different times and test the different process times of the program. \
\
From here I copied the data I got, made estimates using Amdhal\'92s law that would give me an estimate of where I thought the data would lead, and made graphs corresponding to the data to show my findings. \
\
I found that the least efficient amount of threads to run the program on was 1, while the most efficient was 16 (this is what I expected) \
\
The one thing that surprised me was that the 16 threads had less speedup than 8 threads on the problem size 1024, this was probably because trying to compute this data with 16 threads made it slower due to the sequential time constraints of the program, sometimes parallel computing can make the completion of a program take longer. \
\
}